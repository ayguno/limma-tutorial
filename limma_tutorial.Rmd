---
title: "A working tutorial for modeling gene expression by using limma package"
author: "Ozan Aygun"
date: "May 31, 2017"
output:
  html_document:
    depth: 3
    highlight: tango
    number_sections: yes
    theme: cerulean
    toc: yes
  pdf_document:
    toc: yes
---


```{r setup, include=FALSE, fig.align='center',fig.width=5,fig.height=4}
knitr::opts_chunk$set(echo =TRUE, include = TRUE, message = FALSE,warning = FALSE)
```

___

# Introduction and Summary

```{r}
library(limma)
data.mat <- readRDS("log_expression.rds")
```


# One sample comparisons

In a typical one sample comparison, we ask the following question:

**Which log gene expression ratios (relative to a reference (control or denominator)) is different from zero? (Assuming that all ratios were normalized)**

First we check if the data is (median) normalized (this is important):
```{r}
apply(data.mat,2,median) # It is median normalized
```
Therefore, all columns (experiment conditions) have a median ratio of zero and data looks median normalized (centered) around the zero.

##lmFit() and eBayes()

lmFit() and eBayes() are the workhorse functions for the limma. lmFit() enables us to fit the linear models of interest, for **each gene** in our data set. The model structure is different from the common formula interface we are used to use in lm(), and models are typically specified by using a so called **design matrix**. lm Fit() returns a model object with a type of **MArrayLM**.

eBayes() takes the model object returned by lmFit() and performs emprical Bayes moderation. This involves moderating the standard errors towards a common value obtained from the entire data set. This is importnat for making our inferences robust given the number of independent replicates (biological replicates) in the experiments are often very low (usually 2 for proteomics). eBayes also computes moderated versions of t and F statistics to evaluate differential expression.

## Fitting one-sample comparisons without specifying a design matrix

Note that without defining a design matrix, the default is a unit vector, in other words, lmFit() will assume all columns (samples) are replicates, it will get their average
and perform a one-sample t-test with a H.NULL = 0, it will print the parameters, including 
Ave Exp and logFC (which is AveExp)
Note that by default topTable performs BH adjustment

# Since design matrix is complicated to implement, we need to use lmFit() after extracting individual replicates
# from the original data.

# For example:

# FS20160721_OA_E15_polUB_Fractions..128C.126..Tetra_Ub_K48_iDUB.Control	
# FS20160721_OA_E15_polUB_Fractions..130C.131..Tetra_Ub_K48_iDUB.Control	

# are replicates of Tetra_Ub_K48_iDUB.

data.mat <- d[,grepl("128C.126..Tetra_Ub_K48_iDUB.Control|130C.131..Tetra_Ub_K48_iDUB.Control",names(d))]

row.names(data.mat) <- d$accession_number # We stick the gene names into the expression set as row.names

apply(data.mat,2,median) # It is median normalized


# Using lmFit to fit the linear model for each gene ID

fit <- lmFit(data.mat)
