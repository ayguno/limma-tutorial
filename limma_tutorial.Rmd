---
title: "A working tutorial for modeling gene expression by using limma package"
author: "Ozan Aygun"
date: "May 31, 2017"
output:
  html_document:
    depth: 4
    highlight: tango
    number_sections: yes
    theme: cerulean
    toc: yes
  pdf_document:
    toc: yes
---


```{r setup, include=FALSE, fig.align='center',fig.width=5,fig.height=4}
knitr::opts_chunk$set(echo =TRUE, include = TRUE, message = FALSE,warning = FALSE)
```

___

# Introduction and Summary

```{r,cache=TRUE}

data.mat <- readRDS("log_expression.rds")
```


# One sample comparisons

In a typical one sample comparison, we ask the following question:

**Which log gene expression ratios (relative to a reference (control or denominator)) is different from zero? (Assuming that all ratios were normalized)**

First we check if the data is (median) normalized (this is important):
```{r}
normalization.check <- apply(data.mat,2,median) # It is median normalized
is.normal <- data.frame(Conditions = names(normalization.check),Median = normalization.check)
knitr::kable(is.normal, align = "c", format = "pandoc",row.names = F)
```

Therefore, all columns (experiment conditions) have a median ratio of zero and data looks median normalized (centered) around the zero.

##lmFit() and eBayes()

**lmFit()** and **eBayes()** are the workhorse functions of the limma. lmFit() enables us to fit the linear models of interest, for **each gene** in our data set. The model structure is different from the common formula interface we are used to use in lm(), and models are typically specified by using a so called **design matrix**. lm Fit() returns a model object with a type of **MArrayLM**.

eBayes() takes the model object returned by lmFit() and performs emprical Bayes moderation. This involves moderating the standard errors towards a common value obtained from the entire data set. This is importnat for making our inferences robust given the number of independent replicates (biological replicates) in the experiments are often very low (usually 2 for proteomics). eBayes also computes moderated versions of t and F statistics to evaluate differential expression.

## Fitting one-sample comparisons without specifying a design matrix

Note that without defining a design matrix, the default is a unit vector, in other words, lmFit() will assume all columns (samples) are replicates, it will get their average and perform a one-sample t-test with a H.NULL = 0, it will print the parameters.

For one sample comparisons (essentially one-sample Moderated t-test), it is more intuiutive to feed a pure data matrix into the lmFit that exclusively contains the biological replicates of a particular **class**. (Class is a treatment category, which is represented by biological replicates.)

### Extracting the data.martix for a particular class

For example in our data set:

- FS20160721_OA_E15_polUB_Fractions..128C.126..Tetra_Ub_K48_iDUB.Control	
- FS20160721_OA_E15_polUB_Fractions..130C.131..Tetra_Ub_K48_iDUB.Control	

columns are biological replicates of the experimental treatment class: **Tetra_Ub_K48_iDUB**

**Question: now our question becomes: Which MEAN log gene expression ratios (relative to a reference (control or denominator)) is different from zero in Tetra_Ub_K48_iDUB condition (class)?**

Let's extract the relevant data for this class:

```{r}
data.K48 <- data.mat[,grepl("128C.126..Tetra_Ub_K48_iDUB.Control|130C.131..Tetra_Ub_K48_iDUB.Control",names(data.mat))]
row.names(data.K48) <- row.names(data.mat) # We stick the gene names into the expression set as row.names
```

Note that we stick the gene names (or accession numbers) into the expression set as row.names to the data.matrix before fitting the model. This is not required, but makes the analysis more intuitive.

### Using lmFit to fit the linear model for each gene ID

Using lmFit without a design matrix is very simple:

```{r}
library(limma)
fit <- lmFit(data.K48)
```


### Perform emprical Bayes moderation:

We use the model returned from lmFit to perform emprical Bayes moderation:

```{r}
fit <- eBayes(fit, robust = TRUE)
```

- Note that robust = TRUE makes the inference more robust against outlier sample variances.

### topTable() function: Extract the table of gene sets from the fitted model

In other words, this is the step where we extract the results of differential expression test from the model fit.

topTable() extracts a table of the top-ranked genes from a linear model fit.

- We set: number = nrow(data.mat) to get all genes
- We set: sort.by = "none" to not sort the results and keep the original gene set order

```{r}

significance <- topTable(fit, number = nrow(data.K48), sort.by = "none", adjust.method = "fdr",
                         confint = TRUE)

knitr::kable(head(significance), align = "c", format = "pandoc",row.names = T)
knitr::kable(data.frame(head(fit$coefficients)), align = "c", format = "pandoc",row.names = T)

```

**Note that the estimated coefficients for the model are simply the average expression of the replicates.**


####Interpreting the output table

Note that we are fitting a linear model for every gene in our data.matrix, therefore this implicitly means that we performed many hypothesis tests at the same time and our alpha-level needs to be re-adjusted (i.e: our nominal p-values associated with each test has to be adjusted).

- Note that by default topTable performs BH adjustment for the nominal p-values, we can set this as 'fdr' to adjust p-values by controlling the false discovery rate.

- **P-values** are the raw (nominal) p-values associated with these regression parameters.
- **t** is moderated t-statistic (omitted for topTableF).
- **logFC** is the estimate of the log2-fold-change corresponding to the effect or contrast (for topTableF there may be several columns of log-fold-changes).
- **CI.L and CI.R** left and right limits of the confidence interval for logFC.
- **AveExpr** is average log2-expression for the gene over all conditions in the data matrix.



